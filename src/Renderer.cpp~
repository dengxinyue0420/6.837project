#include "Renderer.h"

#include "ArgParser.h"
#include "Camera.h"
#include "Hit.h"
#include "Image.h"
#include "Ray.h"
#include "VecUtils.h"

#include <limits>

Renderer::Renderer(const ArgParser &args) :
    _args(args),
    _scene(args.input_file),
    _bounces(args.bounces)
{
  for(int i=0;i<_scene.getNumMaterials();i++){
    Material *m = _scene.getMaterial(i);
    Noise *n = m->getNoise();
    std::cout<<n<<std::endl;
  }
}

Renderer::~Renderer()
{
}

// IMPLEMENT THESE FUNCTIONS
// These function definitions are mere suggestions. Change them as you like.
Vector3f 
mirrorDirection(const Vector3f &normal, const Vector3f &incoming)
{
    // TODO: IMPLEMENT
  float cos = Vector3f::dot(incoming,normal);
  return (incoming - 2*cos*normal).normalized();
}

bool
transmittedDirection(const Vector3f &normal, 
                     const Vector3f &incoming, 
                     float index_i,
                     float index_t, 
                     Vector3f &transmitted)
{
    // TODO: IMPLEMENT
  float cos = Vector3f::dot(incoming,normal);
  float ratio = index_i/index_t;
  float check = 1-std::pow(ratio,2)*(1-std::pow(cos,2));
  if(check>0){
    transmitted = ratio*(incoming-cos*normal)-std::sqrt(check)*normal;
    transmitted.normalize();
    return true;
  }
  return false;
}
Vector3f Renderer::traceShade(const Ray &ray, Hit &hit) const{
  Group *group = this->_scene.getGroup();
  Vector3f newPoint = ray.pointAtParameter(hit.getT());
  int numLight = this->_scene.getNumLights();
  Material *m = hit.getMaterial();
  Vector3f s  = Vector3f::ZERO;
  for(int i=0;i<numLight;i++){
    Vector3f dirLight, colorLight;
    float disToLight;
    Light *l =this->_scene.getLight(i);
    l->getIllumination(newPoint,dirLight,colorLight,disToLight);
    Ray rayToLight = Ray(newPoint,dirLight.normalized());
    Hit h = Hit();
    //std::cout<<"3"<<std::endl;
    if(group->intersect(rayToLight,0.01,h)){
      if(h.getT()>disToLight){
	s+=m->shade(ray,hit,dirLight,colorLight);
      }
    }else{
      //std::cout<<"not"<<std::endl;
      s+=m->shade(ray,hit,dirLight,colorLight);
    }
  }
  return s;
}

Vector3f
Renderer::traceRay(const Ray &ray, 
                   float tmin, 
                   int bounces,
                   float refr_index, 
                   Hit &hit) const
{
    // TODO: IMPLEMENT 
  if(bounces==-1){
    return Vector3f::ZERO;
  }
  Vector3f shadow = this->traceShade(ray,hit);
  Vector3f reflection = Vector3f::ZERO;
  Vector3f refraction = Vector3f::ZERO;
  Vector3f hitPoint = ray.pointAtParameter(hit.getT());
  Material *m = hit.getMaterial();
  Vector3f normal = hit.getNormal();
  Vector3f rayDirection = ray.getDirection();
  Vector3f mirror = mirrorDirection(normal,rayDirection);
  Hit reflectH = Hit();
  Ray mirrorRay = Ray(hitPoint,mirror);
  Group *g = this->_scene.getGroup();
  if(g->intersect(mirrorRay,0.01,reflectH)){
    reflection = m->getSpecularColor()*traceRay(mirrorRay,0.01,bounces-1,refr_index,reflectH);
  }else{
    reflection = this->_scene.getBackgroundColor(mirror);
  }
  Vector3f transmit=Vector3f::ZERO;
  Hit refractH = Hit();
  float R0=1;
  float c = 0.0f;
  if(transmittedDirection(normal,rayDirection,refr_index,m->getRefractionIndex(),transmit)){
    float index_nt = refractH.getMaterial()->getRefractionIndex();
    Ray transmitRay(hitPoint,transmit);
    if(g->intersect(transmitRay,0.01,refractH)){
      refraction = traceRay(transmitRay,0.01,bounces-1,index_nt,refractH);
    }else{
      refraction = this->_scene.getBackgroundColor(transmit);
    }
    if(refr_index<=index_nt){
      c = std::abs(Vector3f::dot(rayDirection,normal));
    }else{
      c = std::abs(Vector3f::dot(transmit,normal));
    }
    R0 = std::pow((index_nt-refr_index)/(index_nt+refr_index),2);
  }
  float R = R0+(1-R0)*std::pow(1-c,5);
  return shadow+R*reflection+(1-R)*refraction;
}
void
Renderer::Render()
{
    // TODO: IMPLEMENT 

    // This is the main loop that should be based on your assignment 4 main
    // loop. You will need to modify it to switch from ray casting to ray
    // tracing, to cast shadows and anti-aliasing (via jittering and
    // filtering).
  int width = this->_args.width;
  int height = this->_args.height;
  int stats = this->_args.stats;
  int minDepth = this->_args.depth_min;
  int maxDepth = this->_args.depth_max;
  std::string outputFilename = this->_args.output_file;
  std::string depthFilename = this->_args.depth_file;
  std::string normalFilename = this->_args.normals_file;


  float x_step = 2.0/width;
  float y_step = 2.0/height;
  
  Camera * cam = this->_scene.getCamera();
  Group * group = this->_scene.getGroup();
  Image outputF = Image(width,height);
  Image depthF = Image(width,height);
  Image normalF = Image(width,height);

  Vector3f ambientLight = this->_scene.getAmbientLight();
  int numLights = this->_scene.getNumLights();
  Vector3f bgcolor = this->_scene.getBackgroundColor(Vector3f::ZERO);

  std::cout<<"Iterate over pixel"<<std::endl;
  for(int i=60;i<width;i++){
    for(int j=0;j<height;j++){
      //std::cout<<"i="<<i<<"\tj="<<j<<std::endl;
      Ray r = cam->generateRay(Vector2f(-1+i*x_step, -1+j*y_step));
      Hit h = Hit();
      if(group->intersect(r,cam->getTMin(),h)){
	Material *m = h.getMaterial();
	Vector3f s = Vector3f::ZERO;
	//std::cout<<"Trace Ray"<<std::endl;
	s+=traceRay(r,0.0,this->_bounces,1,h);
	//std::cout<<"end trace ray"<<std::endl;
	s+=m->getDiffuseColor()*ambientLight;
	
	outputF.setPixel(i,j,s);
      }else{
	outputF.setPixel(i,j,bgcolor);
      }
    }
  }
  outputF.savePNG(outputFilename);

}

